== UnetStack basics

UnetStack is an _agent-based network stack_. Each _agent_ is similar to a _layer_ in a traditional network stack, but has more flexibility and a richer set of interaction semantics that empower it to use the scarce resources (bandwidth, energy, etc) in the Unet more efficiently. In order to develop Unet applications, we need to understand some basic concepts in UnetStack.

=== Agent-based framework

UnetStack is based on the open-source {url-fjage}[fjåge] framework that provides agent development capability in Java and Groovy. The framework also publishes API bindings to other languages such as Python, Julia and C. There are a few essential concepts from fjåge that we need to understand to effectively use UnetStack:

Agent:: An agent is logical entity that implements a specific functionality of the network. Loosely, an agent maps to a layer in a traditional network stack, but is more flexible. Each agent has its own thread of execution, and all agents can be thought of as running concurrently.

Message:: Agents interact with each other via messages. Agents can send and receive messages, and typically expose all their functionality as a set of messages that they will respond to. Messages are transmitted within the network stack on a node, and not between nodes in the network.

Performative:: Each message is tagged with a performative that summarizes the purpose of the message. Common performatives are `REQUEST`, `AGREE`, `REFUSE`, `FAILURE`, `NOT_UNDERSTOOD` and `INFORM`. The next few defintions explain these further.

Request:: Request messages ask an agent to perform some task. Such messages are marked with the performative `REQUEST`, and it is a convention to name the message class with a suffix `Req` (e.g. `DatagramReq`, `ParameterReq`).

Response:: When an agent receives a request, it must respond back to the requesting agent. Common responses are simply messages with the performative set to `AGREE`, `REFUSE`, `FAILURE` or `NOT_UNDERSTOOD`. An `AGREE` message confirms to the requester that the agent will perform the requested task. A `REFUSE` message tells the requester that the request cannot be performed at this time. A `FAILURE` message, on the other hand, means that the agent should have been able to do the request under normal circumstances, but something went wrong. A `NOT_UNDERSTOOD` response is generated if the agent does not know how to deal with the request. Other than these simple messages, responses may sometimes contain more information. Such messages are respresented by message classes with a suffix `Rsp` (e.g. `ParameterRsp`), and may have a performative of `INFORM` to indicate that they contain information in response to the request.

Notification:: Agents sometimes generate unsolicited information. This information is encapsulated in a notification message, typically with a performative `INFORM`. Notification messages may be sent to a specific agent, or on a topic.

Topic:: A topic defines a publish-subscribe mechanism where an agent may publish some notifications, and other agents interested in those notifications may _subscribe_ to the topic. Most agents have an unnamed topic associated with themselves, that other agents can subscribe to. For example, a data link agent may subscribe to the topic of a physical layer agent to listen for incoming data frames from the physical layer.

Parameters:: Most UnetStack agents publish a number of parameters associated with them. Parameters are key-value pairs that provide information about the agent (read-only parameters), or allow controlling the behavior of the agent (read-write parameters). Parameters are technically accessed via `ParameterReq` and `ParameterRsp` messages, but a simpler notation (`agent.parameter`) is also available to get/set parameters.

Service:: A service is a collection of messages (requests, responses and notifications) and parameters that an agent honors. Agents publish the list of services they offer, and other agents may find agents through the services they advertise. A list of UnetStack services is available in <<_service_reference>>.

While these ideas may seem somewhat abstract at this point in time, we will see them at work shortly and they will become clearer.

=== The command shell

The simplest way to interact with UnetStack is via the command shell (or simply _shell_). The shell may be accessed on the console, a TCP/IP port or via the web interface. In <<Getting started>>, we have already seen how to set up a 2-node network and access the command shell for each of the nodes using a web browser. For the rest of this section, we assume that you have shells open on nodes A and B.

On node A, we can ask for a list of agents running:

[source, console]
----
> ps
remote: org.arl.unet.remote.RemoteControl - IDLE
state: org.arl.unet.state.StateManager - IDLE
rdp: org.arl.unet.net.RouteDiscoveryProtocol - IDLE
ranging: org.arl.unet.phy.Ranging - IDLE
uwlink: org.arl.unet.link.ECLink - IDLE
node: org.arl.unet.nodeinfo.NodeInfo - IDLE
websh: org.arl.fjage.shell.ShellAgent - RUNNING
simulator: org.arl.unet.sim.SimulationAgent - IDLE
phy: org.arl.unet.sim.HalfDuplexModem - IDLE
bbmon: org.arl.unet.bb.BasebandSignalMonitor - IDLE
arp: org.arl.unet.addr.AddressResolution - IDLE
transport: org.arl.unet.transport.SWTransport - IDLE
router: org.arl.unet.net.Router - IDLE
mac: org.arl.unet.mac.CSMA - IDLE
----

We can further ask for more details of a specific agent:

[source, console]
----
> phy
<<< HalfDuplexModem >>>

[org.arl.unet.DatagramParam]
  MTU = 56

[org.arl.unet.bb.BasebandParam]
  basebandRate = 12000.0
  carrierFrequency = 12000.0
  maxPreambleID = 4
  maxSignalLength = 65536
  preambleDuration = 0.2
  signalPowerLevel = -10.0

[org.arl.unet.phy.PhysicalParam]
  busy = false
  maxPowerLevel = 0.0
  minPowerLevel = -96.0
  propagationSpeed = 1534.4574
  refPowerLevel = 185.0
  rxEnable = true
  rxSensitivity = -200.0
  time = 2302208594
  timestampedTxDelay = 1.0

[org.arl.unet.sim.HalfDuplexModemParam]
  basebandRxDuration = 1.0
  clockOffset = 2263.2524
----

We asked for details of the agent `phy`, and we got a list of parameters supported by the agent. We can get or set individual parameters of the agent:

[source, console]
----
> phy.MTU
56
> phy.rxEnable
true
> phy.rxEnable = false
false
> phy.rxEnable
false
> phy.rxEnable = true
true
----

To find out more about a specific parameter, we can ask for help on the parameter:

[source, console]
----
> help phy.MTU
phy.MTU - maximum transmission unit (MTU) in bytes
> help phy.rxEnable
phy.rxEnable - true if reception enabled
----

We can also ask for help on an agent:

[source, console]
----
> help phy
phy - access to physical service

Examples:
  phy                           // access physical parameters
  phy[CONTROL]                  // access control channel parameters
  phy[DATA]                     // access data channel parameters
  phy << msg                    // send request msg to physical agent
  phy.rxEnable = false          // disable reception of frames

Commands:

- plvl - get/set TX power level for all PHY channel types

Parameters:

The following parameters are available on all modems. Additional modem
dependent parameters are also available. For information on these
parameters type "help modem".

- phy.MTU - maximum transmission unit (MTU) in bytes
- phy.rxEnable - true if reception enabled
- phy.propagationSpeed - propagation speed in m/s
- phy.timestampedTxDelay - delay before TX of timestamped frames
- phy.time - physical layer time (us)
- phy.busy - true if modem is TX/RX a frame, false if idle
- phy.refPowerLevel - reference power level in dB re uPa @ 1m
- phy.maxPowerLevel - maximum supported power level (relative to reference)
- phy.minPowerLevel - minimum supported power level (relative to reference)

Channel Parameters:

The following parameters are available on all modems. Additional modem
dependent parameters are also available. For information on these
parameters type "help modem".

- phy[].MTU - maximum transmission unit (MTU) in bytes
- phy[].dataRate - effective frame data rate (bps)
- phy[].frameDuration - frame duration (seconds)
- phy[].powerLevel - powel level used for transmission (relative to reference)
- phy[].errorDetection - number of bytes for error detection
- phy[].frameLength - frame length (bytes)
- phy[].maxFrameLength - maximum settable frame length (bytes)
- phy[].fec - forward error correction code
- phy[].fecList - list of available forward error correction codes
----

From this help, we see that `phy` agent also support channel parameters (also known as _indexed_ parameters). It supports two logical channels, CONTROL (1) and DATA (2). The CONTROL channel is meant for low-rate robust data transmission, whereas the DATA channel is typically configured for higher rate data transmission. Channel parameters work in the same way as normal parameters, but with an index:

[source, console]
----
> phy[CONTROL]
<<< PHY >>>

[org.arl.unet.DatagramParam]
  MTU = 16

[org.arl.unet.phy.PhysicalChannelParam]
  dataRate = 256.0
  errorDetection = 1
  fec = 0
  fecList = null
  frameDuration = 0.95
  frameLength = 24
  janus = false
  llr = false
  maxFrameLength = 128
  powerLevel = -10.0

> phy[DATA]
<<< PHY >>>

[org.arl.unet.DatagramParam]
  MTU = 56

[org.arl.unet.phy.PhysicalChannelParam]
  dataRate = 1024.0
  errorDetection = 1
  fec = 0
  fecList = null
  frameDuration = 0.7
  frameLength = 64
  janus = false
  llr = false
  maxFrameLength = 512
  powerLevel = -10.0

> phy[CONTROL].MTU
16
> phy[CONTROL].frameLength = 32
32
> phy[CONTROL].frameLength
32
> phy[CONTROL].MTU
24
> phy[CONTROL].frameLength = 24
24
----

NOTE: The actual parameters you see may differ if you are working with a modem, depending on the specific capabilities of the modem. Use `help` to find out more about any listed parameter on your modem, or refer to the modem's documentation for further information.

Most agents also support some commands. For example, the `phy` agent supports the `plvl` command:

[source, console]
----
> help plvl
plvl - get/set TX power level for all PHY channel types

Examples:
  plvl                       // get all power levels
  plvl -10                   // set all power to -10 dB
  plvl(-10)                  // alternative syntax
  plvl = -10                 // alternative syntax

> plvl
phy[1].powerLevel = -10.0
phy[2].powerLevel = -10.0
phy[3].powerLevel = -10.0
phy.signalPowerLevel = -10.0
> plvl -20
OK
> plvl
phy[1].powerLevel = -20.0
phy[2].powerLevel = -20.0
phy[3].powerLevel = -20.0
phy.signalPowerLevel = -20.0
----

The `plvl` command simply displays or sets the `powerLevel` parameter of all channels. The same can be manually accomplished by setting or getting individual parameters, if desired:

[source, console]
----
> phy[1].powerLevel
-20
> phy[1].powerLevel = -10
-10
> phy[1].powerLevel
-10
> plvl
phy[1].powerLevel = -10.0
phy[2].powerLevel = -20.0
phy[3].powerLevel = -20.0
phy.signalPowerLevel = -20.0
----

=== Interacting with agents using messages

Most agents also support a set of messages. Typically, we would want to send a request message to an agent and get a response message back. This can be accomplished with the `request` call (or the equivalent alias `<<`) on the agent:

[source, console]
----
> phy.request new TxFrameReq()
AGREE
phy >> TxFrameNtf:INFORM[type:CONTROL txTime:2893654740]
> phy << new TxFrameReq()
AGREE
phy >> TxFrameNtf:INFORM[type:CONTROL txTime:2913909740]
----

Here we made a request to the `phy` agent to transmit a frame. The agent responded with an `AGREE` response, shortly followed by a `TxFrameNtf` notification from `phy` telling us that the transmission was successful.

The `request` call sends a message and waits for a timeout (typically 1 second) for a response. If we did not wish to wait for a response, we could make a `send` call to send the message. The call would return immediately, and any response would be simply printed on the shell later as a notification:

[source, console]
----
> phy.send new TxFrameReq()
phy >> AGREE
phy >> TxFrameNtf:INFORM[type:CONTROL txTime:3043490740]
----

The difference between the two is not obvious from the above, since the `request` call's return value `AGREE` is printed on the shell anyway. However, we can assign the response message from `request` to a variable (but we can't do that with `send`):

[source, console]
----
> x = phy << new TxFrameReq();
phy >> TxFrameNtf:INFORM[type:CONTROL txTime:3381446740]
> x
AGREE
----

TIP: The semicolon ";" at the end of the first statement prevents the return value from being printed on the shell.

We can also use the return value in a condition, but we need to remember that the return value from the `request` is a message:

[source, console]
----
> x.class
class org.arl.fjage.Message
> x.performative
AGREE
> if (x.performative == Performative.AGREE) print 'OK'
OK
----

Unsolicited notification messages can be received by subscribing to the topic of interest. On node B, we can subscribe to events at the physical layer:

[source, console]
----
> subscribe phy
----

Now, if we broadcast a frame from node A using `phy << new TxFrameReq()`, we will see the relevant reception events on node B:

[source, console]
----
phy >> RxFrameStartNtf:INFORM[type:CONTROL rxTime:1765508396]
phy >> RxFrameNtf:INFORM[type:CONTROL from:232 rxTime:1765508396]
----

The first event `RxFrameStartNtf` is triggered as soon as the frame is detected at node B. The second event `RxFrameNtf` is triggered when the frame is fully received, demodulated and successfully decoded at the receiver.

=== Shell scripting

The shell accepts any {groovy}[Groovy] code, and so is very flexible:

[source, console]
----
> 1+2
3
> 5.times { print it }
0
1
2
3
4
----

You can also define closures (if you're not familiar with closures, you can think of them as functions for now):

[source, console]
----
> tx2 = { 2.times { phy << new TxFrameReq() } };
----

and call them later:

[source, console]
----
> tx2
phy >> TxFrameNtf:INFORM[type:CONTROL txTime:3911898740]
phy >> TxFrameNtf:INFORM[type:CONTROL txTime:3912307740]
----

This only scratches the surface of what the command shell is capable of. However, it should provide you a basic understanding of how the shell works, and illustrate its power. To understand more, we suggest that you explore the online `help`. As you further understand the UnetStack and fjåge Java API and the UnetStack service reference (<<_service_reference>>) better, you'll develop expertise on using the shell.
